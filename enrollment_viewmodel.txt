import Foundation
import Combine
import SwiftUI

// MARK: - Enrollment ViewModel
class EnrollmentViewModel: ObservableObject {
    // MARK: - Published Properties
    @Published var personalInfo = PersonalInfo()
    @Published var selectedPlanId: String?
    @Published var beneficiaries: [Beneficiary] = []
    @Published var medicalHistory = MedicalHistory()
    @Published var uploadedDocuments: [UploadedDocument] = []
    @Published var availablePlans: [InsurancePlan] = []
    
    @Published var dateOfBirth = Date()
    @Published var lastPhysicalDate = Date()
    
    @Published var agreesToTerms = false
    @Published var agreesToPrivacyPolicy = false
    
    @Published var isLoading = false
    @Published var isUploading = false
    @Published var showingAlert = false
    @Published var alertMessage = ""
    @Published var enrollmentCompleted = false
    
    // MARK: - Internal Properties
    var editingBeneficiaryIndex: Int?
    private var cancellables = Set<AnyCancellable>()
    
    // Managers
    private let sqlManager = SQLManager.shared
    private let dropboxManager = DropboxManager.shared
    private let messagingManager = MessagingManager.shared
    private let apiManager = APIManager.shared
    
    // Current enrollment ID
    private var currentEnrollmentId: String?
    
    init() {
        setupBindings()
    }
    
    // MARK: - Setup
    private func setupBindings() {
        // Update personal info when date of birth changes
        $dateOfBirth
            .sink { [weak self] date in
                self?.personalInfo.dateOfBirth = ISO8601DateFormatter().string(from: date)
            }
            .store(in: &cancellables)
        
        // Update medical history when last physical date changes
        $lastPhysicalDate
            .sink { [weak self] date in
                self?.medicalHistory.lastPhysicalDate = ISO8601DateFormatter().string(from: date)
            }
            .store(in: &cancellables)
    }
    
    // MARK: - Public Methods
    func loadInsurancePlans() {
        isLoading = true
        
        // Load from API or use cached plans
        apiManager.getInsurancePlans()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.showError("Failed to load insurance plans: \(error.localizedDescription)")
                    }
                },
                receiveValue: { [weak self] plans in
                    self?.availablePlans = plans
                    self?.isLoading = false
                }
            )
            .store(in: &cancellables)
    }
    
    func canProceed(from step: EnrollmentStep) -> Bool {
        switch step {
        case .personalInfo:
            return isPersonalInfoValid()
        case .planSelection:
            return selectedPlanId != nil
        case .beneficiaries:
            return true // Beneficiaries are optional
        case .medicalHistory:
            return true // Basic medical history is always valid
        case .documents:
            return hasRequiredDocuments()
        case .review:
            return agreesToTerms && agreesToPrivacyPolicy
        }
    }
    
    func submitEnrollment() {
        guard canProceed(from: .review) else {
            showError("Please complete all required fields and agree to terms.")
            return
        }
        
        isLoading = true
        
        // Create enrollment data
        let enrollmentData = EnrollmentData(
            id: UUID().uuidString,
            userId: getCurrentUserId(),
            planId: selectedPlanId!,
            status: "pending",
            personalInfo: personalInfo,
            beneficiaries: beneficiaries,
            medicalHistory: medicalHistory
        )
        
        // Save to database and sync to Dropbox
        sqlManager.createEnrollment(enrollmentData)
            .flatMap { [weak self] enrollmentId -> AnyPublisher<Bool, Error> in
                self?.currentEnrollmentId = enrollmentId
                
                // Upload all documents to the enrollment folder
                return self?.uploadEnrollmentDocuments(enrollmentId: enrollmentId) ?? 
                       Just(true).setFailureType(to: Error.self).eraseToAnyPublisher()
            }
            .flatMap { [weak self] _ -> AnyPublisher<String, Error> in
                // Send welcome message
                return self?.sendEnrollmentConfirmationMessage() ?? 
                       Just("").setFailureType(to: Error.self).eraseToAnyPublisher()
            }
            .flatMap { [weak self] _ -> AnyPublisher<Bool, Error> in
                // Notify VPS system
                return self?.notifyVPSSystem() ?? 
                       Just(true).setFailureType(to: Error.self).eraseToAnyPublisher()
            }
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isLoading = false
                    if case .failure(let error) = completion {
                        self?.showError("Enrollment submission failed: \(error.localizedDescription)")
                    }
                },
                receiveValue: { [weak self] success in
                    self?.enrollmentCompleted = true
                    self?.showSuccess("Your enrollment has been submitted successfully! You'll receive a confirmation email shortly.")
                    
                    // Post notification for other parts of the app
                    NotificationCenter.default.post(
                        name: .enrollmentSubmitted,
                        object: nil,
                        userInfo: ["enrollmentId": self?.currentEnrollmentId ?? ""]
                    )
                }
            )
            .store(in: &cancellables)
    }
    
    func uploadDocuments(_ selectedDocuments: [SelectedDocument]) {
        isUploading = true
        
        let uploadPublishers = selectedDocuments.map { document in
            uploadSingleDocument(document)
        }
        
        Publishers.MergeMany(uploadPublishers)
            .collect()
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { [weak self] completion in
                    self?.isUploading = false
                    if case .failure(let error) = completion {
                        self?.showError("Document upload failed: \(error.localizedDescription)")
                    }
                },
                receiveValue: { [weak self] uploadedDocs in
                    self?.uploadedDocuments.append(contentsOf: uploadedDocs)
                    self?.showSuccess("Documents uploaded successfully!")
                }
            )
            .store(in: &cancellables)
    }
    
    func deleteDocument(_ document: UploadedDocument) {
        // Remove from Dropbox
        dropboxManager.deleteFile(path: document.dropboxPath)
            .receive(on: DispatchQueue.main)
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        print("Failed to delete document from Dropbox: \(error)")
                    }
                },
                receiveValue: { [weak self] success in
                    // Remove from local array
                    self?.uploadedDocuments.removeAll { $0.id == document.id }
                }
            )
            .store(in: &cancellables)
    }
    
    func hasDocument(type: String) -> Bool {
        return uploadedDocuments.contains { $0.documentType == type }
    }
    
    var selectedPlan: InsurancePlan? {
        return availablePlans.first { $0.id == selectedPlanId }
    }
    
    // MARK: - Private Methods
    private func isPersonalInfoValid() -> Bool {
        return !personalInfo.firstName.isEmpty &&
               !personalInfo.lastName.isEmpty &&
               !personalInfo.email.isEmpty &&
               isValidEmail(personalInfo.email) &&
               !personalInfo.phone.isEmpty &&
               !personalInfo.address.street.isEmpty &&
               !personalInfo.address.city.isEmpty &&
               !personalInfo.address.state.isEmpty &&
               !personalInfo.address.zipCode.isEmpty
    }
    
    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPred = NSPredicate(format:"SELF MATCHES %@", emailRegEx)
        return emailPred.evaluate(with: email)
    }
    
    private func hasRequiredDocuments() -> Bool {
        let requiredTypes = ["photo_id", "ssn_card", "income_proof"]
        return requiredTypes.allSatisfy { type in
            hasDocument(type: type)
        }
    }
    
    private func uploadSingleDocument(_ selectedDocument: SelectedDocument) -> AnyPublisher<UploadedDocument, Error> {
        let documentType = determineDocumentType(fileName: selectedDocument.fileName)
        let fileName = "\(UUID().uuidString)_\(selectedDocument.fileName)"
        let folderPath = "\(DropboxManager.Config.Folders.documents)/temp"
        
        return dropboxManager.uploadFile(
            data: selectedDocument.data,
            fileName: fileName,
            folderPath: folderPath,
            metadata: [
                "document_type": documentType,
                "original_filename": selectedDocument.fileName,
                "mime_type": selectedDocument.mimeType,
                "upload_date": ISO8601DateFormatter().string(from: Date())
            ]
        )
        .map { fileInfo in
            UploadedDocument(
                fileName: selectedDocument.fileName,
                fileSize: selectedDocument.data.count,
                documentType: documentType,
                dropboxPath: fileInfo.path,
                uploadDate: Date()
            )
        }
        .eraseToAnyPublisher()
    }
    
    private func determineDocumentType(fileName: String) -> String {
        let lowercaseName = fileName.lowercased()
        
        if lowercaseName.contains("license") || lowercaseName.contains("id") || lowercaseName.contains("passport") {
            return "photo_id"
        } else if lowercaseName.contains("social") || lowercaseName.contains("ssn") {
            return "ssn_card"
        } else if lowercaseName.contains("pay") || lowercaseName.contains("income") || lowercaseName.contains("tax") {
            return "income_proof"
        } else if lowercaseName.contains("insurance") || lowercaseName.contains("coverage") {
            return "previous_coverage"
        } else if lowercaseName.contains("medical") || lowercaseName.contains("health") {
            return "medical_records"
        } else {
            return "other"
        }
    }
    
    private func uploadEnrollmentDocuments(enrollmentId: String) -> AnyPublisher<Bool, Error> {
        let enrollmentFolderPath = "\(DropboxManager.Config.Folders.enrollments)/\(enrollmentId)/documents"
        
        // Move documents from temp folder to enrollment folder
        let movePublishers = uploadedDocuments.map { document in
            moveDocumentToEnrollmentFolder(document: document, enrollmentFolderPath: enrollmentFolderPath)
        }
        
        return Publishers.MergeMany(movePublishers)
            .collect()
            .map { _ in true }
            .eraseToAnyPublisher()
    }
    
    private func moveDocumentToEnrollmentFolder(
        document: UploadedDocument, 
        enrollmentFolderPath: String
    ) -> AnyPublisher<Bool, Error> {
        
        return dropboxManager.downloadFile(path: document.dropboxPath)
            .flatMap { [weak self] data in
                guard let self = self else {
                    return Fail<Bool, Error>(error: APIError.invalidResponse).eraseToAnyPublisher()
                }
                
                return self.dropboxManager.uploadFile(
                    data: data,
                    fileName: document.fileName,
                    folderPath: enrollmentFolderPath,
                    metadata: [
                        "document_type": document.documentType,
                        "enrollment_id": self.currentEnrollmentId ?? "",
                        "moved_from": document.dropboxPath
                    ],
                    enrollmentId: self.currentEnrollmentId
                )
                .map { _ in true }
            }
            .eraseToAnyPublisher()
    }
    
    private func sendEnrollmentConfirmationMessage() -> AnyPublisher<String, Error> {
        guard let enrollmentId = currentEnrollmentId else {
            return Fail(error: APIError.missingEnrollmentId).eraseToAnyPublisher()
        }
        
        let confirmationMessage = """
        Welcome to Centuries Mutual!
        
        Your enrollment application has been received and is being processed. Here are the next steps:
        
        1. Our team will review your application within 2-3 business days
        2. We may contact you if additional information is needed
        3. Once approved, you'll receive your policy documents via this app
        4. Your coverage will begin on the effective date specified in your application
        
        Your enrollment ID is: \(enrollmentId)
        
        If you have any questions, please reply to this message or contact our support team.
        
        Thank you for choosing Centuries Mutual for your health insurance needs!
        """
        
        return messagingManager.sendAdminMessage(
            to: getCurrentUserId(),
            subject: "Welcome to Centuries Mutual - Enrollment Received",
            message: confirmationMessage,
            enrollmentId: enrollmentId,
            priority: .normal
        )
    }
    
    private func notifyVPSSystem() -> AnyPublisher<Bool, Error> {
        guard let enrollmentId = currentEnrollmentId else {
            return Fail(error: APIError.missingEnrollmentId).eraseToAnyPublisher()
        }
        
        let notificationData = EnrollmentNotification(
            enrollmentId: enrollmentId,
            userId: getCurrentUserId(),
            planId: selectedPlanId!,
            status: "submitted",
            timestamp: Date(),
            documentsUploaded: uploadedDocuments.count,
            requiresReview: true
        )
        
        return apiManager.notifyVPSEnrollment(notificationData)
    }
    
    private func getCurrentUserId() -> String {
        return UserDefaults.standard.string(forKey: "current_user_id") ?? "unknown_user"
    }
    
    private func showError(_ message: String) {
        alertMessage = message
        showingAlert = true
    }
    
    private func showSuccess(_ message: String) {
        alertMessage = message
        showingAlert = true
    }
}

// MARK: - API Manager
class APIManager: ObservableObject {
    static let shared = APIManager()
    
    private let baseURL = "YOUR_VPS_API_BASE_URL" // Replace with actual VPS URL
    private let session = URLSession.shared
    private var cancellables = Set<AnyCancellable>()
    
    private init() {}
    
    // MARK: - Insurance Plans
    func getInsurancePlans() -> AnyPublisher<[InsurancePlan], Error> {
        // For demo purposes, return mock data
        // In production, this would make an actual API call
        return Just(mockInsurancePlans())
            .setFailureType(to: Error.self)
            .delay(for: .seconds(1), scheduler: DispatchQueue.main)
            .eraseToAnyPublisher()
    }
    
    // MARK: - VPS Integration
    func notifyVPSEnrollment(_ notification: EnrollmentNotification) -> AnyPublisher<Bool, Error> {
        return Future { promise in
            // Create the API request to VPS
            guard let url = URL(string: "\(self.baseURL)/api/enrollments/notify") else {
                promise(.failure(APIError.invalidURL))
                return
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.setValue("Bearer \(self.getAPIToken())", forHTTPHeaderField: "Authorization")
            
            do {
                request.httpBody = try JSONEncoder().encode(notification)
            } catch {
                promise(.failure(error))
                return
            }
            
            // For demo purposes, simulate success
            DispatchQueue.global().asyncAfter(deadline: .now() + 1.0) {
                promise(.success(true))
            }
            
            /* Uncomment for actual API call:
            URLSession.shared.dataTask(with: request) { data, response, error in
                if let error = error {
                    promise(.failure(error))
                    return
                }
                
                guard let httpResponse = response as? HTTPURLResponse,
                      200...299 ~= httpResponse.statusCode else {
                    promise(.failure(APIError.serverError))
                    return
                }
                
                promise(.success(true))
            }.resume()
            */
        }
        .eraseToAnyPublisher()
    }
    
    func syncEnrollmentData(_ enrollmentId: String) -> AnyPublisher<Bool, Error> {
        return Future { promise in
            guard let url = URL(string: "\(self.baseURL)/api/enrollments/\(enrollmentId)/sync") else {
                promise(.failure(APIError.invalidURL))
                return
            }
            
            var request = URLRequest(url: url)
            request.httpMethod = "POST"
            request.setValue("Bearer \(self.getAPIToken())", forHTTPHeaderField: "Authorization")
            
            // Simulate API call
            DispatchQueue.global().asyncAfter(deadline: .now() + 0.5) {
                promise(.success(true))
            }
        }
        .eraseToAnyPublisher()
    }
    
    func getEnrollmentStatus(_ enrollmentId: String) -> AnyPublisher<EnrollmentStatus, Error> {
        return Future { promise in
            // Simulate API call to get enrollment status
            DispatchQueue.global().asyncAfter(deadline: .now() + 0.5) {
                let status = EnrollmentStatus(
                    enrollmentId: enrollmentId,
                    status: "under_review",
                    lastUpdated: Date(),
                    reviewComments: nil,
                    estimatedCompletionDate: Calendar.current.date(byAdding: .day, value: 3, to: Date())
                )
                promise(.success(status))
            }
        }
        .eraseToAnyPublisher()
    }
    
    // MARK: - Helper Methods
    private func getAPIToken() -> String {
        return UserDefaults.standard.string(forKey: "vps_api_token") ?? "demo_token"
    }
    
    private func mockInsurancePlans() -> [InsurancePlan] {
        return [
            InsurancePlan(
                id: "basic_plan",
                name: "Centuries Basic",
                type: "HMO",
                coverageDetails: "Basic coverage with network providers only. Includes preventive care, emergency services, and prescription drugs.",
                premiumMonthly: 299.99,
                deductible: 1500,
                copayPrimary: 25,
                copaySpecialist: 50,
                outOfPocketMax: 6000,
                networkProviders: "Regional network of healthcare providers",
                planDocumentPath: "/plans/basic_plan_details.pdf",
                active: true
            ),
            InsurancePlan(
                id: "premium_plan",
                name: "Centuries Premium",
                type: "PPO",
                coverageDetails: "Comprehensive coverage with both in-network and out-of-network benefits. Includes dental and vision.",
                premiumMonthly: 459.99,
                deductible: 1000,
                copayPrimary: 20,
                copaySpecialist: 40,
                outOfPocketMax: 4500,
                networkProviders: "National network with premium providers",
                planDocumentPath: "/plans/premium_plan_details.pdf",
                active: true
            ),
            InsurancePlan(
                id: "family_plan",
                name: "Centuries Family",
                type: "EPO",
                coverageDetails: "Family-focused plan with pediatric care, maternity benefits, and family wellness programs.",
                premiumMonthly: 799.99,
                deductible: 2000,
                copayPrimary: 30,
                copaySpecialist: 60,
                outOfPocketMax: 8000,
                networkProviders: "Family-friendly provider network",
                planDocumentPath: "/plans/family_plan_details.pdf",
                active: true
            )
        ]
    }
}

// MARK: - Supporting Models
struct EnrollmentNotification: Codable {
    let enrollmentId: String
    let userId: String
    let planId: String
    let status: String
    let timestamp: Date
    let documentsUploaded: Int
    let requiresReview: Bool
}

struct EnrollmentStatus: Codable {
    let enrollmentId: String
    let status: String
    let lastUpdated: Date
    let reviewComments: String?
    let estimatedCompletionDate: Date?
}

// MARK: - Error Types
enum APIError: LocalizedError {
    case invalidURL
    case invalidResponse
    case serverError
    case missingEnrollmentId
    case authenticationFailed
    
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "Invalid API URL"
        case .invalidResponse:
            return "Invalid response from server"
        case .serverError:
            return "Server error occurred"
        case .missingEnrollmentId:
            return "Missing enrollment ID"
        case .authenticationFailed:
            return "Authentication failed"
        }
    }
}

// MARK: - Dropbox Extension for File Deletion
extension DropboxManager {
    func deleteFile(path: String) -> AnyPublisher<Bool, Error> {
        return Future { promise in
            guard let client = DropboxClientsManager.authorizedClient?.files else {
                promise(.failure(DropboxError.notAuthenticated))
                return
            }
            
            client.deleteV2(path: path).response { response, error in
                if let error = error {
                    promise(.failure(DropboxError.deleteFailed(error.description)))
                } else {
                    promise(.success(true))
                }
            }
        }
        .eraseToAnyPublisher()
    }
}

extension DropboxError {
    case deleteFailed(String)
}

// MARK: - Notifications
extension NSNotification.Name {
    static let enrollmentSubmitted = NSNotification.Name("enrollmentSubmitted")
    static let enrollmentStatusChanged = NSNotification.Name("enrollmentStatusChanged")
    static let documentsUploaded = NSNotification.Name("documentsUploaded")
}

// MARK: - Integration with Existing Circle API
extension EnrollmentViewModel {
    func integrationWithCircleAPI() {
        // If user has Circle wallet, set up automatic premium payments
        if let circleAPI = AppContext.shared.circleAPI,
           let selectedPlan = selectedPlan {
            
            // Set up recurring payment for premium
            setupAutomaticPremiumPayment(planCost: selectedPlan.premiumMonthly)
        }
    }
    
    private func setupAutomaticPremiumPayment(planCost: Double) {
        // Integration with Circle API for automatic payments
        // This would set up a recurring payment from user's Circle wallet
        print("Setting up automatic premium payment of $\(planCost) per month")
        
        // You could also offer incentives through Circle integration
        if let earningsManager = AppContext.shared.currentUserEarningsManager {
            earningsManager.addEarning(
                type: .bonus,
                amount: 25.0,
                description: "Health Insurance Enrollment Bonus"
            )
        }
    }
}